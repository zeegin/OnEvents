name: Generate event from issue

on:
  issues:
    types:
      - opened

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  create-event-file:

    runs-on: ubuntu-latest
    steps:
      - name: Create event file from issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { issue } = context.payload;
            const { owner, repo } = context.repo;

            const normalizeLineEndings = (text) => (text || '').replace(/\r\n/g, '\n');

            const body = normalizeLineEndings(issue.body || '').trim();
            if (!body) {
              core.setFailed('Issue body is empty.');
              return;
            }

            const mapping = {
              'Дата': 'date',
              'Город': 'city',
              'Адрес проведения': 'address',
              'Логотип': 'icon',
              'Ссылка на регистрацию': 'registration_url',
              'Краткое описание события': 'description',
            };

            const parsed = {};
            const regex = /###\s+([^\n]+)\n+([\s\S]*?)(?=\n###\s+|$)/g;
            let match;
            while ((match = regex.exec(body)) !== null) {
              const label = match[1].trim();
              const key = mapping[label];
              if (!key) {
                continue;
              }
              const value = match[2].trim();
              parsed[key] = value;
            }

            const requiredFields = ['date', 'city', 'description', 'registration_url'];
            for (const field of requiredFields) {
              if (!parsed[field] || !parsed[field].trim()) {
                core.setFailed(`Поле "${field}" отсутствует или пустое в обращении.`);
                return;
              }
            }

            parsed.address = parsed.address ? parsed.address.trim() : '';
            parsed.icon = parsed.icon ? parsed.icon.trim() : 'default.jpg';

            const rawTitle = issue.title.replace(/^\[NEW EVENT\]\s*:?\s*/i, '').trim();
            parsed.title = rawTitle || issue.title.trim();
            parsed.date = parsed.date.trim();
            parsed.city = parsed.city.trim();
            parsed.description = parsed.description.trim();
            parsed.registration_url = parsed.registration_url.trim();

            const slugBase = (parsed.title || 'event')
              .normalize('NFKD')
              .replace(/[\u0300-\u036f]/g, '')
              .replace(/[^A-Za-z0-9]+/g, '_')
              .replace(/^_+|_+$/g, '')
              .toUpperCase();

            const baseName = `${parsed.date}_${slugBase || 'EVENT'}`;
            let filePath = `events/${baseName}.yml`;
            let counter = 1;

            while (true) {
              try {
                await github.rest.repos.getContent({ owner, repo, path: filePath });
                counter += 1;
                filePath = `events/${baseName}_${counter}.yml`;
              } catch (error) {
                if (error.status === 404) {
                  break;
                }
                throw error;
              }
            }

            const branchSlugBase = (slugBase || 'EVENT')
              .toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/^-+|-+$/g, '') || 'event';

            const baseBranch = context.payload.repository?.default_branch || 'main';
            const { data: baseBranchRef } = await github.rest.git.getRef({
              owner,
              repo,
              ref: `heads/${baseBranch}`,
            });
            const baseSha = baseBranchRef.object.sha;

            let branchName = `new-event/${branchSlugBase}`;
            let branchCounter = 1;
            while (true) {
              try {
                await github.rest.git.getRef({
                  owner,
                  repo,
                  ref: `heads/${branchName}`,
                });
                branchCounter += 1;
                branchName = `new-event/${branchSlugBase}-${branchCounter}`;
              } catch (error) {
                if (error.status === 404) {
                  break;
                }
                throw error;
              }
            }

            await github.rest.git.createRef({
              owner,
              repo,
              ref: `refs/heads/${branchName}`,
              sha: baseSha,
            });

            const formatValue = (value) => {
              if (value === undefined || value === null || value === '') {
                return '""';
              }
              if (typeof value !== 'string') {
                value = String(value);
              }
              if (value.includes('\n')) {
                const lines = value.split('\n').map((line) => line.trimEnd());
                const indented = lines.map((line) => `  ${line}`).join('\n');
                return `|\n${indented}`;
              }
              const escaped = value.replace(/"/g, '\\"');
              return `"${escaped}"`;
            };

            const yamlLines = [
              `title: ${formatValue(parsed.title)}`,
              `date: ${formatValue(parsed.date)}`,
              `city: ${formatValue(parsed.city)}`,
              `address: ${formatValue(parsed.address)}`,
              `icon: ${formatValue(parsed.icon)}`,
              `description: ${formatValue(parsed.description)}`,
              `registration_url: ${formatValue(parsed.registration_url)}`,
            ];
            const content = `${yamlLines.join('\n')}\n`;

            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              path: filePath,
              message: `feat: add event from issue #${issue.number}`,
              content: Buffer.from(content, 'utf8').toString('base64'),
              branch: branchName,
            });

            const prTitle = `Add event: ${parsed.title.replace(/\s+/g, ' ').trim()}`;
            const prBody = [
              `Автоматически создано из issue #${issue.number}.`,
              '',
              `- Файл: \`${filePath}\``,
            ].join('\n');
            const { data: pr } = await github.rest.pulls.create({
              owner,
              repo,
              title: prTitle,
              head: branchName,
              base: baseBranch,
              body: prBody,
            });

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issue.number,
              body: `Создан Pull Request #${pr.number} для файла \`${filePath}\`.\n\n${pr.html_url}`,
            });

